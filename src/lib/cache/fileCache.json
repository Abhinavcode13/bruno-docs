{
  "bru-cli/overview": {
    "name": "overview",
    "content": "Bruno CLI\n\n\nWith Bruno CLI, you can run your API collections with ease using simple command line commands.\n\nThis makes it easier to test your APIs in different environments, automate your testing process, and integrate your API tests with your continuous integration and deployment workflows.\n\nInstallation\n\nTo install the Bruno CLI, use the node package manager of your choice, such as NPM:\n```bash copy\nnpm install -g @usebruno/cli\n```\n\nGetting started\n\nNavigate to the directory where your API collection resides, and then run:\n```bash copy\nbru run\n```\nThis command will run all the requests in your collection. You can also run a single request by specifying its filename:\n\n```bash copy\nbru run request.bru\n```\n\nOr run all requests in a folder:\n```bash copy\nbru run folder\n```\n\nIf you need to use an environment, you can specify it with the --env option:\n```bash copy\nbru run folder --env Local\n```\n\nPass Environment variables to your collection using the --env-var option:\n```bash copy\nbru run folder --env Local --env-var JWT_TOKEN=1234\n```\n\nIf you need to collect the results of your API tests, you can specify the --output option:\n```bash copy\nbru run folder --output results.json\n```\n\nOptions\n\n| Option | Details |\n|----------|-------------|\n| -h, --help |  \tShow help|\n| --version | Show version number|\n| -r | Indicates a recursive run (default: false)|\n| --cacert [string] | CA certificate to verify peer against|\n| --env [string] | Environment variables|\n| --env-var [string] | Overwrite a single environment variable, multiple usages possible|\n| -o, --output [string] | Path to write file results to|\n| -f, --format [string] | Format of the file results; available formats are \"json\" (default) or \"junit\"|\n| --insecure | Allow insecure server connections|\n\nDemo\n\n![bru cli](/screenshots/cli-demo.png)\n\nSupport\n\nIf you encounter any issues or have any feedback or suggestions, please raise them on our [GitHub repository](https://github.com/usebruno/bruno)",
    "parentName": "bru-cli",
    "path": "bru-cli/overview"
  },
  "bru-lang/language": {
    "name": "language",
    "content": "Language Design\n\n\nA Bru file is made up of blocks.\nThere are three kinds of blocks\n- Dictionary block\n- Text blocks\n- Array blocks\n\nDictionary block\n\nA dictionary block contains of a set of key value pairs. \n```bash\nget {\n  url: https://api.textlocal.in/send\n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer 123\n  ~transaction-id: {{transactionId}}\n}\n```\nAny key in the dictionary block can be prefixed with `~` to indicate that it is disabled.\n\nText block\n\nA text block is a set of lines\n```bash\nbody {\n  {\n    \"hello\": \"world\"\n  }\n}\n\ntests {\n  expect(res.status).to.equal(200);\n}\n```\n\nArray block\n\nAn array block is a list of strings\n```bash\nvars:secret [\n  access_key,\n  access_secret,\n  ~transactionId\n]\n```\nAny key in the array block can be prefixed with `~` to indicate that it is disabled.\n\n\n\n\n\n",
    "parentName": "bru-lang",
    "path": "bru-lang/language"
  },
  "bru-lang/overview": {
    "name": "overview",
    "content": "Bru Markup Language\n\n\nBru is a simple markup language that utilizes plain text files to document and organize information for your API requests.\n\nThe api requests in your collections are stored as plain text files using this language.\n\nThis allows you to save your API collections in a folder within your code repository, and use your preferred version control system to manage and share them with your team. Collaboration on your API collections can be done through pull requests, as the human-readable file format makes it easy for developers to understand the changes made to the API collection.\n\nBelow is a sample of a Bru file for a `GET` request with some query params\n\n![bru lang sample](/screenshots/github-collection.png)\n\nYou can checkout the sample repository which contains GitHub rest API collection [here](https://github.com/usebruno/github-rest-api-collection)\n\nIf you are wondering why had to design a DSL instead of just using JSON/YAML, you can checkout this [github discussion](https://github.com/usebruno/bruno/discussions/360)\n",
    "parentName": "bru-lang",
    "path": "bru-lang/overview"
  },
  "bru-lang/samples": {
    "name": "samples",
    "content": "Samples\n\n\nHere are a few sample Bru files.\n\nGET\n\n```bash\nget {\n  url: https://api.github.com/users/usebruno\n}\n```\n\nGET with headers\n\n```bash\nget {\n  url: https://api.textlocal.in/send?apiKey=secret&numbers=9988776655&message=hello\n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nPOST with body\n\n```bash\npost {\n  url: https://api.textlocal.in/send\n}\n\nbody {\n  {\n    \"apiKey\": \"secret\",\n    \"numbers\": \"9988776655\",\n    \"message\": \"Woof! lets play with some apis\"\n  }\n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nScripting\n\n```bash\npost {\n  url: https://api.textlocal.in/login\n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\n\nTesting\n\n```bash\npost {\n  url: https://api.textlocal.in/login\n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\ntests {\n  test(\"should be able to login\", function() {\n    expect(res.status).to.equal(201);\n  });\n\n  test(\"should receive the token\", function() {\n    expect(res.body.token).to.be.a('string');\n  });\n}\n```",
    "parentName": "bru-lang",
    "path": "bru-lang/samples"
  },
  "bru-lang/syntax-highlighting": {
    "name": "syntax-highlighting",
    "content": "Syntax Highlighting Support\n\n\nBruno has editor extension released for VS Code.  You can download it from the [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=bruno-api-client.bruno).\n\nExtensions for IntelliJ and the JetBrains family of IDEs are under development.\n",
    "parentName": "bru-lang",
    "path": "bru-lang/syntax-highlighting"
  },
  "bru-lang/tag-reference": {
    "name": "tag-reference",
    "content": "Bru Tag Reference\n\n\nmeta\n\nStore metadata about your request\n```bash\nmeta {\n  name: Get users,\n  type: http\n  seq: 1\n}\n```\n\nThe `seq` is used to store the sequence number. This decides the sort position of your request in the UI.\nThe `type` can be either `http` or `graphql`\n\nget\n\n\nMake a `GET` http call\n```bash\nget {\n  url: https://api.github.com/users/usebruno\n}\n```\npost\n\n\nMake a `POST` http call\n```bash\npost {\n  url: https://api.github.com/users/usebruno\n}\n```\nput\n\n\nMake a `PUT` http call\n```bash\nput {\n  url: https://api.github.com/users/usebruno\n}\n```\ndelete\n\n\nMake a `DELETE` http call\n```bash\ndelete {\n  url: https://api.github.com/users/usebruno\n}\n```\noptions\n\n\nMake a get `OPTIONS` call\n```bash\noptions {\n  url: https://api.github.com/users/usebruno\n}\n```\ntrace\n\n\nMake a `TRACE` http call\n```bash\ntrace {\n  url: https://api.github.com/users/usebruno\n}\n```\nconnect\n\n\nMake a `CONNECT` http call\n```bash\nconnect {\n  url: https://api.github.com/users/usebruno\n}\n```\nhead\n\n\nMake a `HEAD` http call\n```bash\nhead {\n  url: https://api.github.com/users/usebruno\n}\n```\nquery\n\n\nThe request query params\n```bash\nget {\n  url: https://api.textlocal.in/send?apiKey=secret&numbers=9988776655&message=hello\n}\n\nquery {\n  apiKey: secret\n  numbers: 9988776655\n  message: hello\n}\n```\nheaders\n\n\nThe request query headers\n```bash\nget {\n  url: https://api.textlocal.in/send?apiKey=secret&numbers=9988776655&message=hello\n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nbody\n\nThe request body (defaults to json)\n```bash\nbody {\n  {\n    username: 'john',\n    password: 'governingdynamics'\n  }\n}\n```\nbody:text\n\nThe request body as text\n```bash\nbody:text {\n  This is a text body\n}\n```\nbody:xml\n\nThe request body as xml\n```bash\nbody:xml {\n  \n    John\n    30\n  \n}\n```\nbody:form-urlencoded\n\nThe request body as form-urlencoded\n```bash\nbody:form-urlencoded {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:multipart-form\n\nThe request body as multipart-form\n```bash\nbody:multipart-form {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:graphql\n\nThe request body as graphql\n```bash\nbody:graphql {\n  {\n    launchesPast {\n      launch_site {\n        site_name\n      }\n      launch_success\n    }\n  }\n}\n```\nbody:graphql:vars\n\nThe request body as graphql vars\n```bash\nbody:graphql:vars {\n  {\n    \"limit\": 5\n  }\n}\n```\nscript:pre-request\n\nThe request body as pre-request\n```bash\nscript:pre-request {\n  req.setHeader(\"Authorization\", \"{{token}}\");\n}\n```\nscript:post-response\n\nThe request body as post-response\n```bash\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\ntest\n\nThe tests\n```bash\nbody:test {\n  expect(res.status).to.equal(200);\n}\n```\n",
    "parentName": "bru-lang",
    "path": "bru-lang/tag-reference"
  },
  "introduction/manifesto": {
    "name": "manifesto",
    "content": "Manifesto\n\n\nIt's time for a revolution in API client technology. The status quo, represented by Postman, has become bloated and unwieldy. We refuse to be shoehorned into a proprietary version control system for collaborating on API collections.\n\nWe are an opensource project, rising up against the monopoly of bloated and closed systems. We believe that API collections should be co-located within your source code repository, serving as a living set of examples on how to use the API.\n\nBut we realized that the current tools on the market export collections as giant JSON files (a.k.a. ugly blobs), difficult to version control and diff. So we created the *Bru Markup language*, saving information about your API requests using plain text files.\n\nWith Bruno, collections become first-class citizens, co-located with related information and easily version controlled. We say goodbye to bloated workspaces and global environments, and embrace the benefits of co-location.\n\nWe dream of a world where developers can clone a code repo, get it up and running, use Bruno to browse the examples on how to use the API and start playing with it. No more horror stories of *\"Tim had the collections for the payment-api service, but he left the company last month.\"*\n\nJoin us in our mission to create a better API client for developers. Say goodbye to bloatware and hello to simplicity, efficiency and freedom. Try Bruno today and experience the difference for yourself.",
    "parentName": "introduction",
    "path": "introduction/manifesto"
  },
  "introduction/support": {
    "name": "support",
    "content": "Support\n\n\nPlease use [GitHub Issues](https://www.github.com/usebruno/bruno/issues) to provide feedback and raise defects or feature requests.\n\nWe are also on [Twitter](https://twitter.com/use_bruno), [LinkedIn](https://www.linkedin.com/company/usebruno) and [Discord](https://discord.com/invite/KgcZUncpjq)",
    "parentName": "introduction",
    "path": "introduction/support"
  },
  "scripting/getting-started": {
    "name": "getting-started",
    "content": "Scripting\n\n\nBruno offers scripting support to help you to add additional functionality to the tool such as data generation, validation and integration with other tools and systems, including sending intermediate requests, parsing response data, updating environment variables, etc.\n\n![bru lang sample](/screenshots/scripting.png)\n",
    "parentName": "scripting",
    "path": "scripting/getting-started"
  },
  "scripting/response-query": {
    "name": "response-query",
    "content": "Response Query\n\n\nThe `res` object that is available inside the [vars](./vars.html), [assertions](../testing/assertions.html) and [scripting](./introduction.html) contexts can be queried for data by invoking it like below.\n\nThink of it as `lodash.get()` on steroids\n\n```js\nres('order.total')\n```\n\nExamples\n\n```js\nconst data = {\n  customer: {\n    address: {\n      city: \"bangalore\"\n    },\n    orders: [\n      {\n        id: \"order-1\",\n        items: [\n          { id: 1, amount: 10 },\n          { id: 2, amount: 20 }\n        ]\n      },\n      {\n        id: \"order-2\",\n        items: [\n          { id: 3, amount: 30 },\n          { id: 4, amount: 40 }\n        ]\n      }\n    ]\n  }\n};\n```\n| Query                                   |                             Output |\n|:----------------------------------------|-----------------------------------:|\n| res(\"customer.address.city\")            |                          bangalore |\n| res(\"customer.orders.items.amount\")     |                   [10, 20, 30, 40] |\n| res(\"\"customer.orders.items.amount[0]\") |                                 10 |\n| res(\"..items.amount\")                   |                   [10, 20, 30, 40] |\n| res(\"..amount\")                         |                   [10, 20, 30, 40] |\n| res(\"..items.amount[0]\")                |                                 10 |\n| res(\"..items[0].amount\")                |                                 10 |\n| res(\"..items[5].amount\")                |                          undefined |\n| res(\"..id\")                             | [\"order-1\", 1, 2, \"order-2\", 3, 4] |\n| res(\"customer.orders.foo\")              |                          undefined |\n| res(\"..customer.foo\")                   |                          undefined |\n| res(\"..address\")                        |          [\\{ city: \"bangalore\" \\}] |\n| res(\"..address[0]\")                     |            \\{ city: \"bangalore\" \\} |\n\nAPI\n\n\nStandard dot notation\n\n\n**Example:**\n```js\nres('customer.orders.items.amount')\n```\n\nDeep navigation .. double dots\n\n\n**Example:**\n```js\nres('..items.amount')\n```\n\nArray indexing\n\n\n**Example:**\n```js\nres('..items[0].amount')\n```\n\nArray filtering [?] with corresponding filter function\n\n\n**Example:**\n```js\nres('..items[?].amount', i => i.amount > 20)\n```\n\n\nArray mapping [?] with corresponding mapper function\n\n\n**Example:**\n```js\nres('..items[?].amount', i => i.amount + 10)\n```\n\n\n",
    "parentName": "scripting",
    "path": "scripting/response-query"
  },
  "scripting/vars": {
    "name": "vars",
    "content": "Vars\n\n\nVars allow you to set variables before request, and after your receive the response.\n\nIn the *Pre Request Variables* section, you can write any Strings, Numbers or any valid JavaScript literal.\n\nIn the *Post Response Variables* section, you can write any valid JavaScript expression. The res object is available, allowing you to declaratively parse the [response](./javascript-reference.html#response) and set variables, instead of writing scripts to do the same.\n\nFor parsing the response, you can checkout the [response query](./response-query) that allows you to easily query your response.\n\n**Example:**\n![bru vars](/screenshots/vars.png)\n\n![Screenshot showing how to use defined variables in the request body](/screenshots/set-vars.png)\n",
    "parentName": "scripting",
    "path": "scripting/vars"
  },
  "secrets-management/dotenv-file": {
    "name": "dotenv-file",
    "content": "Secrets Management\n\n\nDotEnv File\n\n\nThis approach is inspired by how usually developers manage secrets in their source code.\n\nIn this approach, you can store all your secrets in a `.env` file at the root of your collection folder.\n\nBruno will automatically load the secrets from this file and make them available to your collection via `process.env.`.\n\n![dot env vars](/screenshots/dot-env-vars.png)\n\nYour environment file at `environments/local.bru` would look like\n```bash filename=\"local.bru\"\nvars {\n  host: http://localhost:5005\n  jwtToken: {{process.env.JWT_TOKEN}}\n}\n```\n\nAnd now you can safely check in your collection to source control without worrying about exposing your secrets.\nDon't forget to add `.env` to your `.gitignore` file.\n\nYou can store a `.env.sample` file in your collection folder to help other developers get started with the collection.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/dotenv-file"
  },
  "secrets-management/overview": {
    "name": "overview",
    "content": "Secrets Management\n\n\nProblem Statement\n\n\nIn any collection, there are secrets that need to be managed. These secrets can be anything such as API keys, passwords, or tokens.\n\nA common practice is to store these secrets in environment variables.\n\nThere are two ways in which developers share bruno collections:\n* Check in the collection folder to source control (like git)\n* Export the collection to a file and share it\n\nIn both these cases we want to ensure that the secrets are stripped out of the collection before it is shared.\n\nSolution\n\n\nBruno offers two approaches to manage secrets in collections.\n\n- [DotEnv File](/secrets-management/dotenv-file)\n- [Secret Variables](/secrets-management/secret-variables)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/overview"
  },
  "secrets-management/secret-variables": {
    "name": "secret-variables",
    "content": "Secrets Management\n\n\nSecret Variables\n\n\nIn this approach, you can check the `secret` checkbox for any variable in your environment.\n\nBruno will manage your secrets internally and will not write them into the environment file.\n\n![secret variables](/screenshots/secret-variables.png)\n\nYour environment file at `environments/local.bru` would look like\n```bash filename=\"local.bru\"\nvars {\n  host: http://localhost:5005\n}\nvars:secret [\n  jwtToken\n]\n\n```\n\nAnd now you can safely check in your collection to source control without worrying about exposing your secrets.\n\nWhen you export your collection as a file, Bruno will not export the secret variables.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-variables"
  }
}