{
  "bru-cli/overview": {
    "name": "overview",
    "content": "Bruno CLI\n\n\nWith Bruno CLI, you can run your API collections with ease using simple command line commands.\n\nThis makes it easier to test your APIs in different environments, automate your testing process, and integrate your API tests with your continuous integration and deployment workflows.\n\nInstallation\n\nTo install the Bruno CLI, use the node package manager of your choice, such as NPM:\n```bash copy\nnpm install -g @usebruno/cli\n```\n\nGetting started\n\nNavigate to the directory where your API collection resides, and then run:\n```bash copy\nbru run\n```\nThis command will run all the requests in your collection. You can also run a single request by specifying its filename:\n\n```bash copy\nbru run request.bru\n```\n\nOr run all requests in a folder:\n```bash copy\nbru run folder\n```\n\nIf you need to use an environment, you can specify it with the --env option:\n```bash copy\nbru run folder --env Local\n```\n\nPass Environment variables to your collection using the --env-var option:\n```bash copy\nbru run folder --env Local --env-var JWT_TOKEN=1234\n```\n\nIf you need to collect the results of your API tests, you can specify the --output option:\n```bash copy\nbru run folder --output results.json\n```\n\nOptions\n\n| Option                | Details                                                                       |\n|-----------------------|-------------------------------------------------------------------------------|\n| -h, --help            | \tShow help                                                                    |\n| --version             | Show version number                                                           |\n| -r                    | Indicates a recursive run (default: false)                                    |\n| --cacert [string]     | CA certificate to verify peer against                                         |\n| --env [string]        | Environment variables                                                         |\n| --env-var [string]    | Overwrite a single environment variable, multiple usages possible             |\n| -o, --output [string] | Path to write file results to                                                 |\n| -f, --format [string] | Format of the file results; available formats are \"json\" (default) or \"junit\" |\n| --insecure            | Allow insecure server connections                                             |\n| --tests-only          | Only run requests that have a test                                            |\n| --bail                | Stop execution after a failure of a request, test, or assertion               |\n\nDemo\n\n![bru cli](/screenshots/cli-demo.webp)\n\nSupport\n\nIf you encounter any issues or have any feedback or suggestions, please raise them on our [GitHub repository](",
    "parentName": "bru-cli",
    "path": "bru-cli/overview"
  },
  "bru-lang/language": {
    "name": "language",
    "content": "Language Design\n\n\nA Bru file is made up of blocks.\nThere are three kinds of blocks\n- Dictionary block\n- Text blocks\n- Array blocks\n\nDictionary block\n\nA dictionary block contains of a set of key value pairs. \n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer 123\n  ~transaction-id: {{transactionId}}\n}\n```\nAny key in the dictionary block can be prefixed with `~` to indicate that it is disabled.\n\nText block\n\nA text block is a set of lines\n```bash\nbody {\n  {\n    \"hello\": \"world\"\n  }\n}\n\ntests {\n  expect(res.status).to.equal(200);\n}\n```\n\nArray block\n\nAn array block is a list of strings\n```bash\nvars:secret [\n  access_key,\n  access_secret,\n  ~transactionId\n]\n```\nAny key in the array block can be prefixed with `~` to indicate that it is disabled.\n\n\n\n\n\n",
    "parentName": "bru-lang",
    "path": "bru-lang/language"
  },
  "bru-lang/overview": {
    "name": "overview",
    "content": "Bru Markup Language\n\n\nBru is a simple markup language that utilizes plain text files to document and organize information for your API requests.\n\nThe api requests in your collections are stored as plain text files using this language.\n\nThis allows you to save your API collections in a folder within your code repository, and use your preferred version control system to manage and share them with your team. Collaboration on your API collections can be done through pull requests, as the human-readable file format makes it easy for developers to understand the changes made to the API collection.\n\nBelow is a sample of a Bru file for a `GET` request with some query params\n\n![bru lang sample](/screenshots/github-collection.webp)\n\nYou can checkout the sample repository which contains GitHub rest API collection [here](\n\nIf you are wondering why had to design a DSL instead of just using JSON/YAML, you can checkout this [github discussion](\n",
    "parentName": "bru-lang",
    "path": "bru-lang/overview"
  },
  "bru-lang/samples": {
    "name": "samples",
    "content": "Samples\n\n\nHere are a few sample Bru files.\n\nGET\n\n```bash\nget {\n  url: \n}\n```\n\nGET with headers\n\n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nPOST with body\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"apiKey\": \"secret\",\n    \"numbers\": \"9988776655\",\n    \"message\": \"Woof! lets play with some apis\"\n  }\n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nScripting\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\n\nTesting\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\ntests {\n  test(\"should be able to login\", function() {\n    expect(res.status).to.equal(201);\n  });\n\n  test(\"should receive the token\", function() {\n    expect(res.body.token).to.be.a('string');\n  });\n}\n```",
    "parentName": "bru-lang",
    "path": "bru-lang/samples"
  },
  "bru-lang/syntax-highlighting": {
    "name": "syntax-highlighting",
    "content": "Syntax Highlighting Support\n\n\nBruno has editor extension released for VS Code.  You can download it from the [Visual Studio Marketplace](\n\nExtensions for IntelliJ and the JetBrains family of IDEs are under development.\n",
    "parentName": "bru-lang",
    "path": "bru-lang/syntax-highlighting"
  },
  "bru-lang/tag-reference": {
    "name": "tag-reference",
    "content": "Bru Tag Reference\n\n\nmeta\n\nStore metadata about your request\n```bash\nmeta {\n  name: Get users,\n  type: http\n  seq: 1\n}\n```\n\nThe `seq` is used to store the sequence number. This decides the sort position of your request in the UI.\nThe `type` can be either `http` or `graphql`\n\nget\n\n\nMake a `GET` http call\n```bash\nget {\n  url: \n}\n```\npost\n\n\nMake a `POST` http call\n```bash\npost {\n  url: \n}\n```\nput\n\n\nMake a `PUT` http call\n```bash\nput {\n  url: \n}\n```\ndelete\n\n\nMake a `DELETE` http call\n```bash\ndelete {\n  url: \n}\n```\noptions\n\n\nMake a get `OPTIONS` call\n```bash\noptions {\n  url: \n}\n```\ntrace\n\n\nMake a `TRACE` http call\n```bash\ntrace {\n  url: \n}\n```\nconnect\n\n\nMake a `CONNECT` http call\n```bash\nconnect {\n  url: \n}\n```\nhead\n\n\nMake a `HEAD` http call\n```bash\nhead {\n  url: \n}\n```\nquery\n\n\nThe request query params\n```bash\nget {\n  url: \n}\n\nquery {\n  apiKey: secret\n  numbers: 9988776655\n  message: hello\n}\n```\nheaders\n\n\nThe request query headers\n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nbody\n\nThe request body (defaults to json)\n```bash\nbody {\n  {\n    username: 'john',\n    password: 'governingdynamics'\n  }\n}\n```\nbody:text\n\nThe request body as text\n```bash\nbody:text {\n  This is a text body\n}\n```\nbody:xml\n\nThe request body as xml\n```bash\nbody:xml {\n  \n    John\n    30\n  \n}\n```\nbody:form-urlencoded\n\nThe request body as form-urlencoded\n```bash\nbody:form-urlencoded {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:multipart-form\n\nThe request body as multipart-form\n```bash\nbody:multipart-form {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:graphql\n\nThe request body as graphql\n```bash\nbody:graphql {\n  {\n    launchesPast {\n      launch_site {\n        site_name\n      }\n      launch_success\n    }\n  }\n}\n```\nbody:graphql:vars\n\nThe request body as graphql vars\n```bash\nbody:graphql:vars {\n  {\n    \"limit\": 5\n  }\n}\n```\nscript:pre-request\n\nThe request body as pre-request\n```bash\nscript:pre-request {\n  req.setHeader(\"Authorization\", \"{{token}}\");\n}\n```\nscript:post-response\n\nThe request body as post-response\n```bash\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\ntest\n\nThe tests\n```bash\nbody:test {\n  expect(res.status).to.equal(200);\n}\n```\n",
    "parentName": "bru-lang",
    "path": "bru-lang/tag-reference"
  },
  "introduction/index": {
    "name": "index",
    "content": "import jsonIndexCache from \"@/lib/cache/indexCache.json\";\nimport {Typography} from \"@/components/ui/typography\";\nimport {Button} from \"@/components/ui/button\";\nimport Link from \"next/link\";\nimport {Separator} from \"@/components/ui/separator\";\nimport {cn} from \"@/lib/utils\";\nimport {Component, Dot, FolderDot} from \"lucide-react\";\n\nexport default function Index() {\n  const ListNode = ({ item, depth }) => {\n    const headingLevel = depth > 0 ? \"h4\" : \"h2\"\n\n    return (\n      \n        {depth === 0 && (\n          \n        )}\n        \n          \n          \n            {item.name}\n          \n        \n        \n          {/* Map over children and render each one */}\n          {item.children?.map((child) => (\n            \n              {child.children ? (\n                \n              ) : (\n                \n                  \n                  \n                    \n                      {child.name}\n                    \n                  \n                \n\n              )}\n            \n          ))}\n        \n      \n    );\n  };\n\n  return (\n    \n      {jsonIndexCache?.map((item, index) => (\n        \n      ))}\n    \n  );\n}\n\n",
    "parentName": "introduction",
    "path": "introduction/index"
  },
  "introduction/manifesto": {
    "name": "manifesto",
    "content": "Manifesto\n\n\nIt's time for a revolution in API client technology. The status quo, represented by Postman, has become bloated and unwieldy. We refuse to be shoehorned into a proprietary version control system for collaborating on API collections.\n\nWe are an opensource project, rising up against the monopoly of bloated and closed systems. We believe that API collections should be co-located within your source code repository, serving as a living set of examples on how to use the API.\n\nBut we realized that the current tools on the market export collections as giant JSON files (a.k.a. ugly blobs), difficult to version control and diff. So we created the *Bru Markup language*, saving information about your API requests using plain text files.\n\nWith Bruno, collections become first-class citizens, co-located with related information and easily version controlled. We say goodbye to bloated workspaces and global environments, and embrace the benefits of co-location.\n\nWe dream of a world where developers can clone a code repo, get it up and running, use Bruno to browse the examples on how to use the API and start playing with it. No more horror stories of *\"Tim had the collections for the payment-api service, but he left the company last month.\"*\n\nJoin us in our mission to create a better API client for developers. Say goodbye to bloatware and hello to simplicity, efficiency and freedom. Try Bruno today and experience the difference for yourself.",
    "parentName": "introduction",
    "path": "introduction/manifesto"
  },
  "introduction/support": {
    "name": "support",
    "content": "Support\n\n\nPlease use [GitHub Issues]( to provide feedback and raise defects or feature requests.\n\nWe are also on [Twitter]( [LinkedIn]( and [Discord](",
    "parentName": "introduction",
    "path": "introduction/support"
  },
  "license-management/organization/activate-license": {
    "name": "activate-license",
    "content": "Activate Organization License\n\n\nBelow are the steps to activate an organization license.\n\nStep 1: Click on the key icon in Bruno\n\nThe key icon is located at the bottom left corner of the Bruno window. Click on the key icon to open the license management window.\n\n![login](/screenshots/license-management/organization/click-license-icon.png)\n\nStep 2: Select Organization License\n\nSelect the organization option to continue with the organization license activation.\n\n![login-otp](/screenshots/license-management/organization/select-org-license.png)\n\nStep 3: Enter License details\n\nEnter the license key and your email and click on the `Activate` button to activate the license.\n\n![login-otp](/screenshots/license-management/organization/enter-license-details.png)\n\nStep 4: License Activated\n\nOnce the license is activated, you will see a success message.\n\n![login-otp](/screenshots/license-management/organization/license-activated.png)",
    "parentName": "license-management",
    "path": "license-management/organization/activate-license"
  },
  "license-management/organization/manage-licenses": {
    "name": "manage-licenses",
    "content": "Manage Organization Licenses\n\n\nYou can manage your organization's licenses by visiting [Bruno License Manager](\n\nBelow are the steps to manage your organization's licenses:\n\nStep 1: Login to Bruno License Manager\n\nPlease enter your email to login to Bruno License Manager.\n\n![login](/screenshots/license-management/organization/login.png)\n\nStep 2: Enter the OTP\n\nPlease enter the OTP sent to your email.\n\n![login-otp](/screenshots/license-management/organization/login-otp.png)\n\nStep 3: Manage Licenses\n\nYou can view and manage your organization's licenses here.\n\n![login-otp](/screenshots/license-management/organization/user-licenses.png)\n\nPlease note that you need manually share the license key with your team members. \nIn the upcoming releases, we will add the ability to send the license key to your team members via email.\n",
    "parentName": "license-management",
    "path": "license-management/organization/manage-licenses"
  },
  "license-management/overview": {
    "name": "overview",
    "content": "License Management\n\n\nOrganization License\n\n  * [Managing License](/license-management/organization/manage-licenses)\n  * [Activating License](/license-management/organization/activate-license)\n",
    "parentName": "license-management",
    "path": "license-management/overview"
  },
  "migration-imports/introduction": {
    "name": "introduction",
    "content": "import {\n  Button\n} from \"../../components/ui/button\";\nimport Link from \"next/link\";\n\nImporting existing collections\n\n\nYou can import collections from various sources such as Postman, Bruno, OpenAPI, or Insomnia:\nCurrently, the following sources are supported:\n- Postman\n- Bruno\n- OpenAPI v3\n- Insomnia\n\nHere are our guides on how to import collections from some of these sources:\n\n\n  \n    \n        Postman\n    \n  \n  Bruno\n  OpenAPI\n  Insomnia\n\n\n",
    "parentName": "migration-imports",
    "path": "migration-imports/introduction"
  },
  "migration-imports/postman": {
    "name": "postman",
    "content": "import Image from 'next/image'\n\nMigrating from Postman\n\n\nCollection Import\n\nOpen Postman and select the collection you want to migrate. Click on the `···` followed by `View more actions` to open the dropdown menu and scroll down until you find `Export`, then click on it.\n\n\n  \n  \n\n\nA popup dialog will appear, select either `Collection v2` or `Collection v2.1` format and click on the `Export` button.\n\n\n\nThe collection will be downloaded as a JSON file. Now open Bruno and select `···` followed by `Import Collection` in the dropdown menu.\\\nA popup dialog will appear, asking you to select the API client you want to import from. Select `Postman Collection` and provide your previously exported collection file.\n\n\n\nYou will then be prompted to select the location where you want to save the imported collection. Select the desired location and click on the `Import` button.\n\n\n\nCongratulations! You have successfully migrated your collection from Postman to Bruno.\\\nYour scripts and tests will be automatically converted to Bruno's syntax.\n\nEnvironment Import\n\n\nOpen Postman and select the environment you want to migrate. Click on the `···` to open the dropdown menu, followed by `Export` and eventually choose a location to save the environment file.\n\n\n\nNow open Bruno and open a collection by clicking on any request.\nA button in the upper right corner will appear, click on it and select `Configure`.\n\n\n\nA dialog will appear, displaying your previously exported environment file. Select the `Import` button in the bottom left corner to proceed.\nSelect `Postman Environment`, provide the environment file and that's it!",
    "parentName": "migration-imports",
    "path": "migration-imports/postman"
  },
  "scripting/external-libraries": {
    "name": "external-libraries",
    "content": "External Libraries\n\n\nBruno supports loading any npm module to use in your scripting workflows.\n\nYou need to add a `package.json` file where your collection is stored.\n```js\n{\n  \"name\": \"github-rest-api-collection\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"homepage\": \"\n  \"dependencies\": {\n    \"@faker-js/faker\": \"8.3.1\"\n  }\n}\n```\n\nAnd then run npm install inside your collection folder\n```bash\nnpm install\n```\n\nAnd then you can require the node module in your script as usual.\n**Example:**\n```js\nconst { faker } = require('@faker-js/faker');\n\nconst randomName = faker.name.fullName();\nconst randomEmail = faker.internet.email();\n\nreq.setBody({\n  name: randomName,\n  email: randomEmail\n});\n```\n",
    "parentName": "scripting",
    "path": "scripting/external-libraries"
  },
  "scripting/inbuilt-libraries": {
    "name": "inbuilt-libraries",
    "content": "Inbuilt Libraries\n\n\nBelow are the list of inbuilt libraries that you can `require`  in your scripts.\n\n- [ajv]( - Ajv JSON schema validator\n- [axios]( - Promise based HTTP client for the browser and node.js\n- [node-fetch]( - A light-weight module that brings Fetch API to Node.js.\n- [atob]( -  Turn base64-encoded ascii data back to binary.\n- [btoa]( -  Turn binary data to base64-encoded ascii.\n- [chai]( -  BDD/TDD assertion library for node.js and the browser.\n- [lodash]( -  A modern JavaScript utility library delivering modularity, performance & extras.\n- [moment]( -  Parse, validate, manipulate, and display dates and times in JavaScript.\n- [uuid]( -  For the creation of RFC4122 UUIDs\n- [nanoid]( - A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n- [crypto-js]( - JavaScript library of crypto standards.\n\n\n**Example:**\n```js\nconst { nanoid } = require(\"nanoid\");\n\nreq.setHeader(\"transaction-id\", nanoid());\n```\n",
    "parentName": "scripting",
    "path": "scripting/inbuilt-libraries"
  },
  "scripting/javascript-reference": {
    "name": "javascript-reference",
    "content": "JavaScript API Reference\n\n\nHere is the complete set of API reference for the scripting feature in Bruno.\n\nRequest\n\nThis `req` variable is available inside your scripting and testing context.\n\nBelow is the API documentation for the methods available on `req`\n`getUrl`\n\nGet the current request url\n\n**Example:**\n```javascript\nlet url = req.getUrl();\n```\n\n`setUrl`\n\nSet the current request url\n\n**Example:**\n```javascript\nreq.setUrl(\"\n```\n\n`getMethod`\n\nGet the current request method\n\n**Example:**\n```javascript\nconst method = req.getMethod();\n```\n\n`setMethod`\n\nSet the current request method\n\n**Example:**\n```javascript\nreq.setMethod(\"POST\");\n```\n\n`getHeader`\n\nGet the request header by name\n\n**Example:**\n```javascript\nreq.getHeader(\"transaction-id\");\n```\n\n`getHeaders`\n\nGet the current request headers\n\n**Example:**\n```javascript\nconst headers = req.getHeaders();\n```\n\n`setHeader`\n\nSet the request header by name\n\n**Example:**\n```javascript\nreq.setHeader( \"content-type\", \"application/json\");\n```\n\n`setHeaders`\n\nSet the current request headers\n\n**Example:**\n```javascript\nreq.setHeaders({\n  \"content-type\": \"application/json\",\n  \"transaction-id\": \"foobar\"\n});\n```\n\n`getBody`\n\nGet the current request body/payload\n\n**Example:**\n```javascript\nconst body = req.getBody();\n```\n\n`setBody`\n\nSet the request body/payload\n\n**Example:**\n```javascript\nreq.setBody({\n  \"username\": \"john nash\",\n  \"password\": \"governingdynamics\"\n});\n```\n\n`setMaxRedirects`\n\nSet the maximum number of redirects to follow\n\n**Example:**\n```javascript\nreq.setMaxRedirects(5);\n```\n\nResponse\n\nThis `res` variable is available inside your scripting and testing context.\n\nBelow are the properties available on the `res` object.\n| Property | Description |\n|----------|-------------|\n| status | The response status code|\n| statusText | The response status text|\n| headers | The response headers|\n| body | The response body|\n| responseTime | The API response time|\n\nBelow are the methods available on the `res` object.\n\n`getStatus`\n\nGet the response status\n\n**Example:**\n```javascript\nlet status = res.getStatus();\n```\n\n`getHeader`\n\nGet the response header by name\n\n**Example:**\n```javascript\nlet transactionId = res.getHeader(\"transaction-id\");\n```\n\n`getHeaders`\n\nGet the response headers\n\n**Example:**\n```javascript\nlet headers = res.getHeaders();\n```\n\n`getBody`\n\nGet the response data\n\n**Example:**\n```javascript\nlet data = res.getBody();\n```\n\n`getResponseTime`\n\nGet the response time\n\n**Example:**\n```javascript\nlet responseTime = res.getResponseTime();\n```\n\n\nbru\n\nThe `bru` variable is available inside your scripting and testing context.\nIt exposes methods that allow you to interact with, e.g., process variables,\nenvironment variables and collection variables.\n\nBelow is the API documentation for the methods available on `bru`\n\n\nNode process environment\n\nBruno allows you to get Node process environment variables on the fly.\n\n`getProcessEnv`\n\nGet the Node process environment variable.  This allows secret token usage without committing secrets to version control.\n\n**Example:**\n```javascript\nlet secret_token = bru.getProcessEnv(\"secret_access_token\");\n```\nEnvironments\n\nBruno allows you to get and set Bruno environment variables on the fly.\n\n`getEnvVar`\n\nGet the Bruno environment variable\n\n**Example:**\n```javascript\nlet token = bru.getEnvVar(\"access_token\");\n```\n`setEnvVar`\n\nSet the Bruno environment variable\n\n**Example:**\n```javascript\nfunction onResponse(res) {\nlet data = res.getBody();\nlet token = bru.setEnvVar(\"access_token\", data.token);\n}\n```\n\nCollection Variables\n\nBruno allows you to get and set collection variables on the fly. The collection variables take precendence over environment variables.\n\n`getVar`\n\nGet the collection variable\n\n**Example:**\n```javascript\nlet petId = bru.getVar(\"petId\");\n```\n`setVar`\n\nSet the collection variable\n\n**Example:**\n```javascript\nlet data = res.getBody();\nbru.setVar(\"petId\", data.id);\n```\n\nRequest Order\n\nYou can influence the order in which requests are being run by the request-runner (UI) or the CLI.\n\n`setNextRequest`\n\nBy default, the collection runner (UI) and the CLI run requests in order.\nYou can change the order by calling `setNextRequest` with the name of the next request to be run.\nThis works only in a post-request script or test-script.\n\n**Example:**\n```javascript\nbru.setNextRequest(\"Get process status\");\n```\n\nYou can also abort the run by explicitly setting the next request to `null`\n**Example:**\n```javascript\nbru.setNextRequest(null);  // aborts the run gracefully\n```",
    "parentName": "scripting",
    "path": "scripting/javascript-reference"
  },
  "scripting/request/request-object": {
    "name": "request-object",
    "content": "Request Object\n\n\nThe `req` object represents the HTTP request made to the server. It contains various properties that define the request details.\n\n`req` Sub-Object\n\n\nThe `req` sub-object contains detailed information about the request.\n\n- `assertions` : An array containing any assertions associated with the request. *See [assertions](/testing/assertions)*.\n- `auth` : An object containing authentication credentials, such as username and password.\n- `headers` : A sub-object representing the HTTP headers associated with the request.\n- `method` : The HTTP method used for the request (e.g., \"GET\", \"POST\").\n- `mode` : The mode of the request (e.g., \"none\", \"cors\").\n- `responseType` : The expected response type for the request (e.g., \"text\", \"json\").\n- `script` : An object containing script-related information for the request.\n- `signal` : A signal object used to abort the request.\n- `url` : The URL of the request.\n- `vars` : An object containing any variables associated with the request. *See [variables](/scripting/variables)*.\n\nHeaders\n\n\nThe `headers` sub-object of the `req` object contains key-value pairs representing the HTTP headers associated with the request.\n\n```javascript\n// Example usage\nconsole.log(req.headers);\n/* Output: {\n  authorization: 'Bearer ',\n  'content-type': 'application/json',\n  accept: 'application/json',\n  // Add more headers as needed...\n} */\n```\n\nMethod\n\n\nThe `method` property of the `req` object specifies the HTTP method used for the request. Common HTTP methods include \"GET\", \"POST\", \"PUT\", \"DELETE\", etc. The method indicates the type of action the request wishes to perform on the resource. The value of the `method` property should be a string representing the desired HTTP method for the request.\n\n```javascript\n// Example usage\nconsole.log(req.method); // Output: \"GET\"\n```\n\nURL\n\n\nThe `url` property of the `req` object represents the Uniform Resource Locator (URL) of the request. It specifies the address of the resource being requested by the client. Variables enclosed within double curly braces (`{{...}}`) in the URL string are placeholders that may be replaced with actual values at runtime. These variables are not directly visible within the URL string and are typically encapsulated during request processing.\n\n```javascript\n// Example usage\nconsole.log(req.url); // Output: \"{{base.url}}/users/2?queryTest=queryResult\"\n```\n\n\nExample Usage\n\n\n```javascript\n// Example request object\nconst req = {\n  assertions: [],\n  auth: { username: 'myUsername', password: 'mySuperPassword' },\n  headers: {\n    authorization: 'Bearer ',\n    'content-type': 'application/json',\n    accept: 'application/json',\n    // Add more headers as needed...\n  },\n  method: 'GET',\n  mode: 'none',\n  responseType: 'arraybuffer',\n  script: {\n    req: \"// Create an array of objects\\nconst data = [\\n  { i…q);\\nconst myVariable = bru.getEnvVar('password');\"\n  },\n  signal: {},\n  url: '{{base.url}}/users/2?queryTest=queryResult',\n  vars: {}\n};\n\n\n// Accessing request properties\nconsole.log(req.method); // Output: \"GET\"\nconsole.log(req.url); // Output: \"{{base.url}}/users/2?queryTest=queryResult\"\nconsole.log(req.headers.authorization); // Output: \"Bearer \"\nconsole.log(req.auth.username); // Output: \"myUsername\"\n```",
    "parentName": "scripting",
    "path": "scripting/request/request-object"
  },
  "scripting/request/sync-requests": {
    "name": "sync-requests",
    "content": "Sync requests\n\n\nYou can make synchronous requests in your pre/post scripts. By synchronous, we mean that you can await a request in your scripting code.\n\nBelow is an inbuilt example of using `axios` library to\n```js\nconst axios = require(\"axios\");\n\nconst response = await axios.get(\"\n\nbru.setVar(\"avatarUrl\", response.data.avatar_url);\n```\n\n**Example:**\n![sync requests](/screenshots/sync-requests.webp)\n\n",
    "parentName": "scripting",
    "path": "scripting/request/sync-requests"
  },
  "scripting/response/response-object": {
    "name": "response-object",
    "content": "import {BetaCard} from \"@/components/beta-card\";\n\nResponse Object\n\n\nThe `res` object that is available inside the [vars](./vars), [assertions](/testing/assertions), [scripting](./introduction) and [testing](/testing/introduction)\ncontexts can be used to extract values from the response body, headers and status.\n\n*Note that the `res` object is only available in the context of a request.*\n\nYou can also access it with [response queries](./response-queries).\n\nObject Structure\n\n\nThe `res` object has the following properties:\n\n- `body`: Represents the response body containing data returned to the client.\n- `headers`: Contains key-value pairs representing HTTP headers associated with the response.\n- `status`: Represents the HTTP status code indicating the outcome of the request.\n\nProperty Descriptions\n\n\n`body`\n\n\nThe `body` property of the `res` object contains the response data sent to the client. It can be a string, an object, or a stream, depending on the application's needs.\n\n`headers`\n\n\nThe `headers` property contains HTTP headers associated with the response. These headers provide metadata about the response, such as content type, encoding, and caching directives.\n\n`status`\n\n\nThe `status` property represents the HTTP status code of the response. It indicates the outcome of the request, such as success, redirection, client error, or server error.\n\nExample Usage\n\n\n```javascript\n// Example response object\nconst res = {\n  body: '{\"message\": \"Hello, world!\"}',\n  headers: {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'no-cache',\n  },\n  status: 200,\n};\n\n// Accessing response properties\nconsole.log(res.body); // Output: '{\"message\": \"Hello, world!\"}'\nconsole.log(res.headers['Content-Type']); // Output: 'application/json'\nconsole.log(res.status); // Output: 200\n```\n\n\n\n\n\n\n\n",
    "parentName": "scripting",
    "path": "scripting/response/response-object"
  },
  "scripting/response/response-query": {
    "name": "response-query",
    "content": "import {BetaCard} from \"@/components/beta-card\";\n\n\nResponse Query\n\n\nThe `res` object that is available inside the [vars](./vars), [assertions](/testing/assertions), [scripting](./introduction) and [testing](/testing/introduction) contexts can be queried for data by invoking it like below.\n\nThink of it as `lodash.get()` on steroids\n\n```javascript\nres('order.total')\n```\n\nExamples\n\n```javascript\nconst data = {\n  customer: {\n    address: {\n      city: \"bangalore\"\n    },\n    orders: [\n      {\n        id: \"order-1\",\n        items: [\n          { id: 1, amount: 10 },\n          { id: 2, amount: 20 }\n        ]\n      },\n      {\n        id: \"order-2\",\n        items: [\n          { id: 3, amount: 30 },\n          { id: 4, amount: 40 }\n        ]\n      }\n    ]\n  },\n};\n```\n| Query                                   | Output                             |\n|-----------------------------------------|------------------------------------|\n| res(\"customer.address.city\")            | bangalore                          |\n| res(\"customer.orders.items.amount\")     | [10, 20, 30, 40]                   |\n| res(\"\"customer.orders.items.amount[0]\") | 10                                 |\n| res(\"..items.amount\")                   | [10, 20, 30, 40]                   | |\n| res(\"..amount\")                         | [10, 20, 30, 40]                   |\n| res(\"..items.amount[0]\")                | 10                                 |\n| res(\"..items[0].amount\")                | 10                                 |\n| res(\"..items[5].amount\")                | undefined                          |\n| res(\"..id\")                             | [\"order-1\", 1, 2, \"order-2\", 3, 4] |\n| res(\"customer.orders.foo\")              | undefined                          |\n| res(\"..customer.foo\")                   | undefined                          |\n| res(\"..address\")                        | [\\{ city: \"bangalore\" \\}]          |\n| res(\"..address[0]\")                     | \\{ city: \"bangalore\" \\}            |\n\nAPI\n\n\nStandard dot notation\n\n\n**Example:**\n```javascript\nres('customer.orders.items.amount')\n```\n\nDeep navigation .. double dots\n\n\n**Example:**\n```javascript\nres('..items.amount')\n```\n\nArray indexing\n\n\n**Example:**\n```javascript\nres('..items[0].amount')\n```\n\nArray filtering [?] with corresponding filter function\n\n\n**Example:**\n```javascript\nres('..items[?].amount', i => i.amount > 20)\n```\n\n\nArray mapping [?] with corresponding mapper function\n\n\n**Example:**\n```javascript\nres('..items[?].amount', i => i.amount + 10)\n```\n\n\n\n\n\n\n\n\n",
    "parentName": "scripting",
    "path": "scripting/response/response-query"
  },
  "scripting/vars": {
    "name": "vars",
    "content": "Vars\n\n\nVars allow you to set variables before request, and after you receive the response.\n\nVars are available **both at collection and request level**.\n\nIn the *Pre Request Variables* section, you can write any Strings, Numbers or any valid JavaScript literal.\n\nIn the *Post Response Variables* section, you can write any valid JavaScript expression. The res object is available, allowing you to declaratively parse the [response](./javascript-reference.html#response) and set variables, instead of writing scripts to do the same.\n\nFor parsing the response, you can checkout the [response query](./response-object) that allows you to easily query your response.\n\n**Example:**\n![bru vars](/screenshots/vars.webp)\n\n![Screenshot showing how to use defined variables in the request body](/screenshots/set-vars.webp)\n",
    "parentName": "scripting",
    "path": "scripting/vars"
  },
  "scripting/whitelisting-modules": {
    "name": "whitelisting-modules",
    "content": "Whitelisting Modules\n\n\nNot all built-in modules are accessible in scripts out of the box in Bruno for security reasons. You can manually enable/whitelist these modules by modifying your `bruno.json`.\n\n**Example:**\n\nTo enable the `child_process` module, you can put the following in your `bruno.json` file:\n\n```json\n{\n  \"scripts\": {\n    \"moduleWhitelist\": [\"child_process\"],\n    \"filesystemAccess\": {\n      \"allow\": true\n    }\n  }\n}\n```\n\nNote that `filesystemAccess` is required for `child_process` to work as expected. This may be required for other built-in modules as well",
    "parentName": "scripting",
    "path": "scripting/whitelisting-modules"
  },
  "secrets-management/dotenv-file": {
    "name": "dotenv-file",
    "content": "Secrets Management\n\n\nDotEnv File\n\n\nThis approach is inspired by how usually developers manage secrets in their source code.\n\nIn this approach, you can store all your secrets in a `.env` file at the root of your collection folder.\n\nBruno will automatically load the secrets from this file and make them available to your collection via `process.env.`.\n\n![dot env vars](/screenshots/dot-env-vars.webp)\n\nYour environment file at `environments/local.bru` would look like\n```bash filename=\"local.bru\"\nvars {\n  host: \n  jwtToken: {{process.env.JWT_TOKEN}}\n}\n```\n\nAnd now you can safely check in your collection to source control without worrying about exposing your secrets.\nDon't forget to add `.env` to your `.gitignore` file.\n\nYou can store a `.env.sample` file in your collection folder to help other developers get started with the collection.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/dotenv-file"
  },
  "secrets-management/overview": {
    "name": "overview",
    "content": "Secrets Management\n\n\nProblem Statement\n\n\nIn any collection, there are secrets that need to be managed. These secrets can be anything such as API keys, passwords, or tokens.\n\nA common practice is to store these secrets in environment variables.\n\nThere are two ways in which developers share bruno collections:\n* Check in the collection folder to source control (like git)\n* Export the collection to a file and share it\n\nIn both these cases we want to ensure that the secrets are stripped out of the collection before it is shared.\n\nSolution\n\n\nBruno offers two approaches to manage secrets in collections.\n\n- [DotEnv File](/secrets-management/dotenv-file)\n- [Secret Variables](/secrets-management/secret-variables)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/overview"
  },
  "secrets-management/secret-variables": {
    "name": "secret-variables",
    "content": "Secrets Management\n\n\nSecret Variables\n\n\nIn this approach, you can check the `secret` checkbox for any variable in your environment.\n\nBruno will manage your secrets internally and will not write them into the environment file.\n\n![secret variables](/screenshots/secret-variables.webp)\n\nYour environment file at `environments/local.bru` would look like\n```bash filename=\"local.bru\"\nvars {\n  host: \n}\nvars:secret [\n  jwtToken\n]\n\n```\n\nAnd now you can safely check in your collection to source control without worrying about exposing your secrets.\n\nWhen you export your collection as a file, Bruno will not export the secret variables.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-variables"
  },
  "testing/assertions": {
    "name": "assertions",
    "content": "Assertions\n\n\nAssertions allow you to declaratively write tests.\n\nThis should cover most of your testing needs. For complex tests, you can write test scripts.\n\n**Example:**\n![bru assertions](/screenshots/assertions.webp)",
    "parentName": "testing",
    "path": "testing/assertions"
  },
  "testing/introduction": {
    "name": "introduction",
    "content": "Testing\n\n\nBruno supports writing automation test scripts in JavaScript for your API requests to assert its behaviour.\n\nSome of the benefits include\n- Increased efficiency: The tests can be run repeatedly, reducing the time and effort required for manual testing.\n- Increased coverage: Automated tests can cover a larger range of scenarios and edge cases compared to manual testing.\n- Continuous integration/continuous delivery (CI/CD): Automated API tests can be integrated into a CI/CD pipeline, ensuring that API changes are thoroughly tested before deployment.\n- Easier maintenance: Automated tests can be easily updated as the API evolves, reducing the maintenance burden compared to manual tests.\n- Easier regression testing: Automated tests can be easily repeated after changes are made to the API, reducing the time required for regression testing.\n\n**Example:**\n```javascript\ntest(\"should be able to login\", function() {\n  const data = res.getBody();\n  expect(res.getStatus()).to.equal(200);\n});\n\ntest(\"should receive the token\", function() {\n  const data = res.getBody();\n  expect(data.token).to.be.a('string');\n});\n```\n\n**Screenshot:**\n\n![bru lang sample](/screenshots/testing.webp)\n",
    "parentName": "testing",
    "path": "testing/introduction"
  },
  "testing/javascript-reference": {
    "name": "javascript-reference",
    "content": "JavaScript API Reference\n\n\nHere is the complete set of API reference for the scripting feature in Bruno.\n\nRequest\n\nThis `req` variable is available inside your scripting and testing context.\n\nBelow is the API documentation for the methods available on `req`\n`getUrl`\n\nGet the current request url\n\n**Example:**\n```js\nlet url = req.getUrl();\n```\n\n`setUrl`\n\nSet the current request url\n\n**Example:**\n```js\nreq.setUrl(\"\n```\n\n`getMethod`\n\nGet the current request method\n\n**Example:**\n```js\nconst method = req.getMethod();\n```\n\n`setMethod`\n\nSet the current request method\n\n**Example:**\n```js\nreq.setMethod(\"POST\");\n```\n\n`getHeader`\n\nGet the request header by name\n\n**Example:**\n```js\nreq.getHeader(\"transaction-id\");\n```\n\n`getHeaders`\n\nGet the current request headers\n\n**Example:**\n```js\nconst headers = req.getHeaders();\n```\n\n`setHeader`\n\nSet the request header by name\n\n**Example:**\n```js\nreq.setHeader( \"content-type\", \"application/json\");\n```\n\n`setHeaders`\n\nSet the current request headers\n\n**Example:**\n```js\nreq.setHeaders({\n  \"content-type\": \"application/json\",\n  \"transaction-id\": \"foobar\"\n});\n```\n\n`getBody`\n\nGet the current request body/payload\n\n**Example:**\n```js\nconst body = req.getBody();\n```\n\n`setBody`\n\nSet the request body/payload\n\n**Example:**\n```js\nreq.setBody({\n  \"username\": \"john nash\",\n  \"password\": \"governingdynamics\"\n});\n```\n\n`setMaxRedirects`\n\nSet the maximum number of redirects to follow\n\n**Example:**\n```js\nreq.setMaxRedirects(5);\n```\n\nResponse\n\nThis `res` variable is available inside your scripting and testing context.\n\nBelow are the properties available on the `res` object.\n| Property | Description |\n|----------|-------------|\n| status | The response status code|\n| statusText | The response status text|\n| headers | The response headers|\n| body | The response body|\n| responseTime | The API response time|\n\nBelow are the methods available on the `res` object.\n\n`getStatus`\n\nGet the response status\n\n**Example:**\n```js\nlet status = res.getStatus();\n```\n\n`getHeader`\n\nGet the response header by name\n\n**Example:**\n```js\nlet transactionId = res.getHeader(\"transaction-id\");\n```\n\n`getHeaders`\n\nGet the response headers\n\n**Example:**\n```js\nlet headers = res.getHeaders();\n```\n\n`getBody`\n\nGet the response data\n\n**Example:**\n```js\nlet data = res.getBody();\n```\n\n`getResponseTime`\n\nGet the response time\n\n**Example:**\n```js\nlet responseTime = res.getResponseTime();\n```\n\nNode process environment\n\nBruno allows you to get Node process environment variables on the fly.\n\n`getProcessEnv`\n\nGet the Node process environment variable.  This allows secret token usage without committing secrets to version control.\n\n**Example:**\n```js\nlet secret_token = bru.getProcessEnv(\"secret_access_token\");\n```\nEnvironments\n\nBruno allows you to get and set Bruno environment variables on the fly.\n\n`getEnvVar`\n\nGet the Bruno environment variable\n\n**Example:**\n```js\nlet token = bru.getEnvVar(\"access_token\");\n```\n`setEnvVar`\n\nSet the Bruno environment variable\n\n**Example:**\n```js\nfunction onResponse(res) {\nlet data = res.getBody();\nlet token = bru.setEnvVar(\"access_token\", data.token);\n}\n```\n\nCollection Variables\n\nBruno allows you to get and set collection variables on the fly. The collection variables take precendence over environment variables.\n\n`getVar`\n\nGet the collection variable\n\n**Example:**\n```js\nlet petId = bru.getVar(\"petId\");\n```\n`setVar`\n\nSet the collection variable\n\n**Example:**\n```js\nlet data = res.getBody();\nbru.setVar(\"petId\", data.id);\n```\n",
    "parentName": "testing",
    "path": "testing/javascript-reference"
  }
}